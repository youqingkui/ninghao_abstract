00-01-什么是 Application Cache

Application Cache 是 HTML5 为应用提供的一种缓存的机制，它可以让基于 Web 的应用程序离线运行。其实它相当于是把应用安装到了用户的浏览器上 … 
在应用里面使用 Application Cache ，需要先去创建一个 Manifest 文件  … 在这个文件里面，你可以指定想要缓存的应用里面的资源 … 
然后在应用的页面上的 <html> 标签里，添加一个 manifest 属性 … 属性的值就是这个 manifest 文件的地址 … 
这样浏览器打开页面的时候，发现有 manifest 属性，就会根据它链接的 manifest 文件，去缓存所需要的资源 … 
用户在下一次访问这个页面的时候，浏览器会直接在 Application Cache 里面提取这些缓存的资源  …    
用户清除浏览器缓存的时候，这些资源也不会受到影响 ….


01-01-准备 Manifest 文件

想让浏览器缓存我们的应用，可以去创建一个 manifest 文件  … 在这个文件里，你可以说明一下，应用里面的哪一些文件需要缓存 … 浏览器会按照这个列表 .. 把指定的资源缓存下来 … 
现在你看到的是一个简单的页面 … 上面有一些文字还有图片 … 点击这个文字会显示一个工具提示 … 
我们先去新建一个 manifest 文件  …
打开 Brackets 编辑器 …  然后找到应用项目的目录  … 
新建一个文件  …   命名为 offline.appcahe  …   manifest 文件的扩展名可以随便tthc命名  … 不过一般来说，我们可以使用 appcache 作为它的扩展名 …   appcache 是 application cache 的简称 …
下面我们需要在这个页面的 <html> 标签上 .. 添加一个  manifest 属性  … 属性的值就是刚才创建的 offline.appcahe 这个文件的地址 … 
manifest="offline.appcache" 
这样用户使用浏览器第一次访问这个带有 manifest 属性的页面的时候  … 浏览器会加载页面 … 完成以后 … 会按照 offline.appcache 文件里面设置的列表去缓存资源 …
当用户下一次再去访问这个页面的时候 … 浏览器会直接从本地的缓存里面调出这个页面来显示  …   
添加 MIME 类型
为了让浏览器正确的解释 manifest 文件  …  我们还得去配置一下服务器 … 去添加一个 text/cache-manifest 的 MIME 类型 … 
如果你有权限可以修改 Web 服务器的配置文件  ..   可以直接去添加这种类型 …   一般就是 httpd.conf 这个配置文件 。
打开这个配置文件以后，找到配置 MIME Type 的地方 ...  然后添加一行代码  …
text/cache-manifest     appcache 
类型是 text/cache-manifest  … 扩展名是 appcache ..
保存配置文件  … 再去重启一下服务器就可以了。  
如果你没有权限去修改服务器的环境  … 可以在应用的根目录下去创建一个 .htaccess 的文件  …  然后添加这样一行代码  …
text/cache-manifest                    appcache 
注意这里介绍的添加 MIME 的方法只适用在，使用 Apache 搭建的 Web 服务器 …  你的应用运行环境如果使用的是其它的服务器 …  比如 IIS 或者 NGINX …
可以去搜索一下为这些服务器添加 MIME Type 的方法 …


01-02-创建 Manifest 文件

下面再回到之前创建的 manifest 文件  …   这个文件的最开始，要输入一个  ..  CACHE MANIFEST
表示这是一个 manifest 文件  …    然后另起一行 …  可以输入其它的内容  …
在这个文件里添加注释的内容 …可以使用一个 # 号，接着是一个空格 …  然后是注释的内容  …
比如我们可以说明一下这个文件的版本  …  # v1 ….  
manifest 文件里可以分成几个部分 …    不同的部分可以使用一个指定的标题文字分隔开 …   CACHE:  NETWORK: 还有 FALLBACK: 
不同部分下面的列表有不同的用处 …   如果不指定这个标题文字的话 … 默认会是 CACHE:   … 也就是需要缓存的地址或者资源列表  …
不过为了让这个文件结构更清晰一起 …  我们先输入这个部分的标题文字  …   输入大写的 CACHE … 再加上一个冒号 ..
CACHE:
回到应用的页面上，我们先去看一下需要缓存的资源 …   
因为这个页面上带有 manifest 属性 … 所以不管怎么样 … 这个页面本身的内容都会被缓存  … 也就是页面上的标签 .. 文字 … 这些内容 …
页面上链接的其它的资源 … 比如 css ，js .. 图片等等　… 这些资源我们需要单独去设置一下 … 才能被缓存 …
下面我们可以把页面上用到的 css 还有 js 文件的地址粘贴到 manifest 文件的 CACHE 区域下面 ...
….
这个列表里的资源的路径可以使用相对的，也可以使用绝对的 … 如果使用相对的路径  …  是相对于 offline.appcache 这个文件的路径  … 
现在浏览器缓存应用的页面的同时 …. 也会把 CACHE 下面的这些东西缓存下来 … 
下面我们去试一下 ..  保存 ….
测试
在浏览器里打开这个页面 …    这里我用的是 Chrome 浏览器 … 打开它的开发者工具里面的控制台 … 
浏览器在缓存应用的时候会在控制台上输出一些有用的信息 … 
刷新一下这个的页面 ….
在控制台上，你会看到发生的一些事件 …  在后面的视频里，我们再详细的介绍一下这些事件 ..
浏览器会根据我们为页面指定的 offline.appcache 文件里的 CACHE 区域下面的列表 … 去缓存一些资源 …
再打开 Resources .. 资源选项器去看一下 …    打开 Application Cache 
offline.appcache …   localhost …
在这里，同样可以看到缓存的资源列表 …   再回到控制台 … 
下面我们再刷新一下这个页面 ..
使用了 Application Cache 的应用页面被浏览器缓存以后 …  下次再访问这个页面的时候 … 浏览器会直接从缓存里面调出这个页面来显示 … 
你会发现，页面上原来的图片没有显示  … 因为我们并没有设置让浏览器缓存这些图片 … 所以在显示这个页面的时候，缓存里并没有这些图片的缓存 .. 
这样他们也就不会显示在页面上 …. 
用户在离线状态下，或者在我们的应用的服务器关闭的情况下 …  这个被缓存的页面仍然可以显示 …  
下面我们可以关掉服务器 …
再刷新一下这个页面 … 
你会发现，除了页面上没有显示没被缓存的图片以后 … 其它的东西仍然可以正常使用 …
点击这个文字 … 会出现工具提示 … 因为它需要的 js 还有 css 文件已经被缓存下来了 ...


01-03-NETWORK - 设置需要联网的资源

使用了 Application Cache 的页面，在访问的时候，页面上的资源必须都要在 Manifest 文件里面列出来 … 不然浏览器就不会载入使用这些资源  …
不过很多时候，我们的应用仍然需要进行联网的操作 …  比如从我们的服务器上获取到一些资源 … 或者从应用上发送一些内容到我们的服务器上等等 … 
这些需求联网的资源 … 可以把它们列在 manifest 的 NETWORK 区域下面 … 
比如在这个页面上 …  所有的图像资源没有显示出来 … 因为我们没有把它们列在 CACHE 的区域下面 ..  你可以把页面上的所有的图像地址列在 CACHE 的区域下面 …
但是，如果你不想缓存这些图像 …  想要联网获取这些图像资源的话 … 可以把图像资源列在 NETWORK 区域的下面 …
先打开 offline.appcache 文件  …
先输入一个区域的标题 …  NETWORK:
在这个区域里 …  我们可以使用资源的前缀 …  也就是我们不需要手工的去指定每一个图像的地址 .. 而是使用一个前缀 … 
页面上的所有的图像文件是在上一级目录的 ...   images 这个目录下面 …   所以在这里，可以这样来写  …  ../images/
这样这个前缀的所有的资源就会通过服务器来提供了 …   浏览器不会从应用缓存里去寻找 images 下面的东西 …
保存 … 
回到应用的页面上 … 刷新 …
控制台上不会再出现找到图像文件的错误提示了 ..  但是页面上的图像仍然没有显示  …   我们需要再去刷新一次 … 
页面上会显示出图像 … 这些资源来自我们的服务器 … 所以如果关掉了服务器 … 或者用户断网离线以后 ….  这些图像资源就不能正常显示 了 …
在 NETWORK: 下面列出的资源，浏览器会到应用的服务器上请求 …  不过如果你有很多资源都需要从服务器上请求 … 我们可以使用一个 * 号通配符 …
回到 manifest 文件  … 
去掉这行代码  … 直接输入一个 * 号 …
这就表示 …  除了在 CACHE 区域下面列出的东西在缓存里调出来以外 … 其它的所有的资源都需要联网获得 …
保存  …. 
打开应用的页面 … 刷新 ….  然后再刷新一次 …
页面上仍然会显示图像资源  …  虽然我们没有把它们列到 CACHE 区域的下面 … 但是 … 在 NETWORK 区域里 … 使用了一个 * 号通配符  … 
这样没有列到 CACHE 里的资源就会直接通过网络去获取 　…


01-04-FALLBACK - 设置资源的替补

在 Manifest 文件里，我们还可以去设置一下 FALLBACK 资源的列表  …  它的作用就是，当某些资源发生错误不能正常载入，这样就会去使用我们指定的替补 … 
FALLBACK
回到 manifest 文件  …  输入 FALLBACK:
首先我们需要指定想要使用替补的资源的链接 …    比如想给 images 下面的资源去指定一个统一的替补 … 
先输入 images/  …  然后再输入一个空格 ….  接着是替补资源的路径  ..  
在 images 目录下面 … 有一个 offline.png …   
这行代码的意思就是 … 如果 images/ 下面的资源出现问题 …   使用 images 目录下面的 offline.png 这个文件代替 ….   这个替补文件会被缓存 …  这样在离线状态下 … 也能正常使用这个替补 …. 
在 FALLBACK 区域里面指定的想要使用替补的资源 … 浏览器都会先去服务器上请求 ..  出现问题了 … 就会使用替补资源 ...
保存 …. 
回到应用的页面  … 刷新一下 …  然后再刷新一下 … 
再去关掉服务器 …  
回到应用页面 … 再刷新  …
因为应用的服务器关闭了 …  所以，浏览器在请求 images 下面的资源的时候，就会遇到问题 …  
这样也就会去使用替补的这个 offline.png 文件 … 
所以在页面上，所有原来显示图像的地方 … 都会去使用 offline.png 这个图像文件   … 
启动服务器 … 
刷新  … 请求图像没有问题 … 页面会显示原本的图像文件   …  
offline.html
下面我们再去设置一个替补  …   这里我事先创建了一个 offline.html 文件  ….
里面显示一行文字 … 提示用户当前离线状态，没有办法打开用户请求的页面  …     然后再打开 index.html …
为页面上出现的第一个图像去添加一个链接  …
让它链接到 gallery-1.html 这个文件  … 
再打开 offline.appcache … 在 FALLBACK 区域的下面 … 
先输入想要使用替补的东西 …  我们去给应用的所有的页面去指定一个替补 …   当用户去访问没有缓存的页面的时候 …   使用 offline.html 这个文件作为替补 ..
注意我们的应用项目是在服务器的 appcache 这个目录里面 … 并不是在根目录的下面  …
所以这个地址可以这样 …    /appcache/  …    它相当于是应用项目的根目录 …
然后是替补资源的地址 …   /appcache/offline.html 
同样上面的这个 images  … 的前面，也可以加上一个 /appcache/ …
保存一下 … 
回到浏览器 … 刷新 …   你会看到 …  浏览器会缓存  offline.html 这个替被文件  …
再刷新一下  ….     然后关掉服务器 … 
点击刚才添加链接的这张图片 …. 会请求访问 gallery-1.html  … 因为我之前并没有访问过这个 gallery-1.html … 所以这个文件不会在应用缓存里面  …
这样浏览器会使用我们指定的替被文件  …    也就是 offline.html 这个文件里的内容 ….   注意… 浏览器的地址仍然是请求的地址 … gallery-1.html …


02-01-Application Cache 事件流程

浏览器如果发现访问的页面的 html 标签上，包含 manifest 属性 … 并且指向了一个 manifest 文件  …   这样在 window 对象的 applicationCache 对象上 … 会发生一系列的事件 …  下面我们来看一下这些事件的流程 … 
首先我们可以清除掉浏览器已经缓存下来的 Application Cache … 
清空浏览器的缓存不会影响到 Application Cache …  如果你用的是 Chrome 浏览器的话 … 可以新建一个标签  … 输入  chrome://appcache-internals/
找到我们的应用的 manifest  …   然后点击 Remove …  可以删除掉这些缓存资源。
事件流程
回到应用的页面 …  打开控制台 …   
因为刚才清空了这个页面的 AppCache … 所以当我们刷新页面的时候 … 相当于是第一次打开这个页面 … 
首先浏览器注意到这个页面的 <html> 标签里面包含 manifest 属性 …   这样会在 applicationCache 对象上发生一个 checking 事件 …
如果浏览器的 AppCache 里面没找到这个 manifest 文件 …  就会触发一个 downloading 事件 …  开始去下载在 manifest 文件里边列出的资源 …
在下载的同时 … 会定期的触发 progress 事件 …   显示出现在下载了多少个文件  … 还剩下多少个文件  …  
下载完成以后 .. 会发生一个 cached 事件 … 表示这些离线资源已经可以使用了  …  
上面介绍的只是一种情况 … 就是浏览器第一次遇见我们的 manifest 文件  …  
如果下次再访问这个页面 …   刷新一下页面 … 表示我们又一次请求这个页面 .. 
同样浏览器会看到 <html> 元素上的 manifest 属性  …  然后发生一个 checking 事件 … 看一下这个属性指向的 manifest 文件是不是已经存在了 .. 
如果它在浏览器的 AppCache 里面 … 并且 manifest 文件本身并没有发生改变 …    会发生一个 NoUpdate 事件 …. 
表示不需要更新离线的资源   … 因为页面指向的 manifest 文件没有变化 …   浏览器会一个字节一个字节的检查 manifest 文件   … 也就是在这个文件里添加一个空格 … 浏览器都会认为 manifest 文件发生了变化 …
我们可以打开这个 offline.appcache  …   在这个注释内容，文件的版本号这里 … 修改一下 …   v1.1 …   然后保存 … 
回到浏览器 …   刷新 … 
看到 manifest 属性 … 检查 manifest 文件 …   发现这个文件已经存在了，但是文件跟上一次检查的时候不一样了 … 因为我们修改文件里的注释内容 … 也就是那个版本号 ..
然后会发生 downloading 事件 … 重新去下载 manifest 文件里面列出的资源  …   在下载的时候，浏览器也会检查这些文件资源是否有更新 … 如果有的话，就会重新下载 … 如果没有的话 … 会跳过去 … 
都下载好以后 … 最后会发生一个 UpdateReady 事件 … 
表示更新已经完成了  …   
不过这个时候，虽然重新下载了更新以后的资源  …  但是页面上仍然使用的是之前的资源  …  
要使用更新之后的资源 … 需要刷新一下页面 …    或者可以去调用，window.applicationCache.swapCache() … 
window 对象下面的 applicationCache 这个对象里的 swapCache 方法。


02-02-更新 AppCache

修改了 manifest 文件以后，浏览器会按照文件里的列表重新去缓存资源 … 完成以后 … 会发生一个 updateready 事件 …  用户在刷新以后，就可以使用新版的资源了  … 
下面我们可以利用 updateready 这个事件，另外再加上 applicationCache 的状态 … 去在这个页面上显示一个提醒信息。提醒用户应用已经更新了，请刷新一下页面。
HTML
先打开应用页面 …  添加一组 <div> 标签  …  上面定义一个 update 的 ID  ..   我们可以把提醒的内容放在这个容器里面 ..
Script
打开 script.js .. 
新建一个函数  …   叫它 function onUpdateReady(){}    ，一会我们要让 updateready 这个事件发生以后，去执行这个函数 .... 在这个函数里 ... 
先获取到 update 容器  …  var message = document.getElementById("message");
然后设置一下它里面的内容  …   message.innerHTML = "<div class='alert alert-warning'>应用已更新，<a href='#' onclick='location.reload()'>点击刷新页面</a></div>"
这里我用了 Bootstrap 的 Alert 组件的样式来显示这个提醒信息   …  
在这个 点击刷新页面 这个链接上 … 添加了一个 onlick 属性 …  设置一下点击这个链接要做的事 …   location.reload()  … 就是刷新当前这个页面 ...
updateready
下面我们再去添加一个 updateready 事件的监听器 … 也就是，当发生这个事件的时候，让它去执行这个 onUpdateReady 函数 … 也就是在页面上显示一个提醒信息 …
window.applicationCache.addEventListener('updateready', onUpdateReady,false);
另外，我们可以再设置一下 …  当 Application Cache 的状态是  UPDATEREADY 的时候  …  也去执行一下 onUpdateReady() 这个函数 … 
if(window.applicationCache.status === window.applicationCache.UPDATEREADY) {
    onUpdateReady();
}
保存一下这个脚本文件  …   因为这个脚本文件是被缓存的资源  …  想让浏览器重新缓存它 … 需要去修改一下 manifest 文件  …  
改一下这个注释的版本信息 ..    保存 … 
测试
回到浏览器 …  刷新一下 …   然后再刷新一下 …  这样浏览器应该会缓存我们修改之后的 script.js  … 并且应用到当前这个页面上 … 
下面，我们再去修改一个地方.. 
打开 index.html   …  改一下这个页面上的这个图像 …    保存  … 
再回到 manifest 文件  … 修改一下版本信息 … 
然后打开浏览器 …     打开浏览器的开发者工具 …   Resources … Application Cache … offline.appcache   …  localhost …
在窗口的最下面，会显示当前的 AppCache 的状态  … 现在是  IDLE  …  也就是空闲状态  …  
刷新一下页面 ..   
浏览器会重新缓存资源  …    最后会触发 updateready 事件 …   现在  AppCache 的状态就会变成 UPDATEREADY …
在页面上，会显示一个提醒  …    应用已更新 … 点击刷新 …  
点击这个链接  … 会刷新当前的页面 …    
AppCache 的状态会变成 IDLE … 同时页面会应用更新之后的资源    ….


03-01-在线与离线事件

用户连接到互联网的时候，浏览器会触发一个 online 事件 …   断开网络的时候，会触发一个 offline 事件 …   在线的时候，navigator.onLine 可以返回一个真的值  …
利用这些东西，我们可以让应用针对在线还有离线这些情况去做出不同的反应  …. 
这个视频我们去实现一个简单的功能 … 就是在用户在联网状态下 … 在应用上显示一个 在线 的小标签  …   断网以后 …  这个在小标签会变成 离线  … 
先看一下需要的 HTML 代码 …  
在这里有一个 <span> 标签  .. 上面定义了 online-status 这个 ID， 另外还有两个 css 类 … badge ，还有 success …..   badge 这个类的样式来自 bootstrap 的 badge 组件 …  默认它的背景颜色是一种灰色 ...
success 这个类的样式就是给小标签添加一个绿色的背景 ..   
标签里的文字默认是 在线 …    在离线的状态下，我们可以去掉 success 这个类 … 然后再把文字改成 离线 …
script.js
打开 script.js 去添加需要的代码  … 
先添加一个 online 还有 offline 事件的监听器 …  这两件事件属于 window 这个对象 … 
window.addEventListener('online',  onlineStatus);
window.addEventListener('offline',  onlineStatus);
这样用户联网或者断网以后，都会去执行这个 onlineStatus  …  在上面，我们再去定义这个函数 …
先获取到用来显示在线或者离线标签的元素  …    
然后用一个 if 语句 … 去判断一下用户的联网状态 ….   navigator.onLine 在处于联网状态的时候，会返回一个真的值  … 
如果用户是联网状态 …  设置状态标签里的文字为 在线 …  再设置它上面使用的 css 类 …  
下面再用一个else … 去定义一下，如果当前的状态是离线的状态要做的事 … 
设置标签里的文字为 离线 ….   用到的 css 类是  badge … 这里我们去掉了 success 类 … 所以在离线的时候，标签的背景会是一种灰色 … 
同样在页面加载以后，需要去调用这个 onlineStatus 函数。
// 在线状态
function onlineStatus() {
     var status = document.getElementById("online-status");
     if (navigator.onLine){
          status.innerHTML = "在线";
          status.className = "badge success";
     }else{
          status.innerHTML = "离线";
          status.className = "badge";
     }
}
测试
保存 … 打开浏览器去测试一下 …   刷新 …
当前的状态是联网的 …  所以这个小标签上会显示，在线 … 并且背景是绿色的 … 
下面我们再断开网络试一下 ….
断网以后，标签文字会变成 离线 …  背景会变成 灰色 … 
如果再次联网的话 …   标签又会变成绿色的在线 ...


03-02-离线应用

这个视频我们把这个在 Web Storage 课程里做好的这个小应用转换成一个可以离线使用的应用  … 
我们可以使用 Application Cache ，把应用需要的资源缓存在本地 … 
不过我们需要先去解决两个问题 …
在文本框里输入内容 … 点击 设置 按钮…  在地址栏上，你会看到，有一些参数  …  表单元素的名称 .. 还有对应的值  …   这样应用里的其它文件可能会用到这些参数还有值  …
不过有一个问题是 … 如果你试着去请求这样的地址 …   Application Cache 会去缓存它 ..   如果在离线的状态下 … Application Cache 在缓存它的时候，就会遇到问题 … 
你可以在地址里面 .. 也就是当前文档的地址的后面加上 # 号 …  后面接着这些参数 …  很多 Ajax 应用都会使用这样的方法  … 
不过这里，我们的小应用不需要使用这些参数  … 所以，我们可以简单的在按钮上，使用 event 对象的 preventDefault() 方法 … 它会防止按钮的默认的行为 … 这样就不会把这些参数添加到地址上了 … 
（#script.js）
点击 设置 按钮，会执行 setStorage()  … 我们先把 event 对象传递给这个函数 …  然后在函数里面，使用 event 对象的 preventDefault()
同样的方法，再处理一下，清理 按钮 … 
在 clearStorage() 里面  … 同样添加一个 event.preventDefault()  …
测试
回到浏览器 … 刷新 … 输入内容 … 设置 …   现在，地址栏上就不会显示刚才那些参数了 ...
CACHE
下面我们可以使用 Application Cache 去设置应用的缓存 … 
打开 index.html ..  在 <html> 标签上添加一个 manifest="offline.appcache"    … 
再去创建这个 offline.appcache …
文件的开始 …  输入 CACHE MANIFEST  .. 下面是一个注释 …    
然后是要缓存的资源  …  可以把它们放在 CACHE: 区域的下面 ...
这里我们只需要去缓存 bootstrap 样式表 … 还有 script.js 这两个文件  … 
CACHE MANIFEST
#v121
CACHE:
http://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css
script.js
保存  ….  回到浏览器 … 打开 控制台 …   刷新一下 …    控制台上会显示浏览器已经缓存了我们的这个应用  … 
下面，我们可以关掉服务器  …   然后再断开互联网 …. 
刷新页面 ….  
页面仍然可以使用 …   因为浏览器会直接从 Application Cache 里面调用当前页面还有相关的资源的缓存 … 
在文本框里输入点内容  … 
点击 设置 …  
然后再试一下 清除 … 
应用的所有的功能，在离线状态下，仍然可以正常的使用  …


