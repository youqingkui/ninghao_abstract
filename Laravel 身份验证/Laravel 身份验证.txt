01-01-用户身份验证的基本配置

Laravel 框架默认的身份验证的配置文件是在 ...  app ，config ... auth.php 这个文件里面。（#打开），这里的每个选项都有很详细的说明。
driver 就是指定身份验证使用的引擎 ...  可以是 database 数据库，这样我们可以使用 Laravel 的 Query Builder 里的方法去验证用户的身份。默认是 eloquent，就是 Laravel 里面的 ORM。这样需要我们再去创建一个用户模型，一会儿再去看一下。
model 选项是去指定用户的模型的名称  ...  如果上面的 driver 使用的是 eloquent ，在这里，就需要去给它指定一个模型。这里默认的用户模型叫做 User ，也就是说，一会儿我们得去创建一个叫 users 的数据表。
table 选项可以指定存储用户信息使用的数据表，在使用 database 作为用户验证的 driver 的时候，我们需要去指定一下用户信息存储在哪个数据表里。这里默认这个数据表叫做 users 。
Password Reminder Settings ，是找回密码功能相关的配置，在这里，我们可以指定一下找回密码功能使用的视图文件，存储 token 的数据表，还有找回密码的过期时间，在后面讲到这个功能的时候，我们再回来看一下这些选项。
现在，我们可以使用所有这些默认的选项，使用 eloquent 作为身份验证的引擎，用户的模型叫做 User 。


01-02-创建用户模型

这个视频，我们去创建一个用户模型。其实 Laravel 框架默认已经给我们准备了一个用户模型。打开 app...  models ..  在这里，有一个 User.php 。（#打开）
这个就是默认的用户模型。在这里，已经给我们定义好了一些属性，还有方法 ...  先设置一下 users 表的主键的名字 ..   
protected $primaryKey = 'user_id';
下面，我们去创建一个跟这个模型对应的 users 数据表。可以使用 artisan 去创建  ... 打开命令行工具 ..  php artisan ... 使用 migrate 命令的 make 方法去创建一个 migration ，它的名字是 create_users_table  ... 在后面再加上一个 create 选项，去指定一下要创建的数据表的名称 ...  这样在这个 migration 里面，可以少写几行代码 ... 
php artisan migrate:make create_users_table --create=users
然后再找到这个 migration ，app  .. database ... migrations  .. 打开 create_users_table  .. 
在这个文件里面，我们再去设计一下 users 这个表的结构  ...  可以使用 Schema 类去创建数据表的结构 ... 
在这里，已经给我们添加好了一个字段 ... 就是 users 表的主键 ...  叫做 id  .. 这里我们可以改成 user_id  .. 另起一行，再去定义这个表里面的其它的字段 ..  先加一个存储用户名字的字段  ...  这个字段的类型是 string  ..  字段的名称叫做 name ...
$table->string('name');
再添加一个用户邮件字段 ...   同样是个字符串类型的字段 ...  名字是 email ...  我们希望这个字段里的内容在这个表里是唯一的 .. .  因为我们不想让不同的用户使用同一个邮件地址 ...  所以，可以在后面使用一个 unique 方法 ... 
$table->string('email')->unique();
然后再去添加一个保密用户密码的字段 ... 可以叫它 password ..   注意这个存储用户密码的字段的长度，至少要是 60 个字符 ... 因为 Laravel 会存储加密以后的密码 ... 
$table->string('password');
这个表里，可以再加一个字段，标示一下用户是不是管理员 ...  如果是这个字段的值就是 1，不是的话，字段的值会是 0 。 这个字段可以使用 boolean  类型 .. 名字是 is_admin  ...  再去设置一下它的默认值  ...  设置成 0  ... 
$table->boolean('is_admin')->default(0);
想要记住用户的登录，需要在这个用户表里，添加一个 remember_token 字段  .. 
$table->string('remember_token');
最后再添加一个 timestamps   ...  它可以生成 created_at 还有 updated_at 字段，存储的是用户创建的时间，还有更新的时间。


01-03-在评论表里添加 user_id 字段

Reviews
下面，我们再打开在 Laravel 数据库 这个课程里创建的一个 reviews 数据表，去添加一个字段 .. 
add_user_id_to_reviews_table
给 reviews 表添加一个 user_id 字段  .. 用户发布评论的时候，在 reviews 表里，存储用户的 id 号 ...  可以使用 Schema 的 table 方法 ... 指定一下要修改的数据表 ...   然后在后面的匿名函数里，去添加一个字段  ...   字段的类型是 integer ... 名称是 user_id ...  这个字段不能为空 ... 
       Schema::table('reviews', function(Blueprint $table)
          {
               $table->integer('user_id')->nullable();
          });
down
再去设置一下 down 方法 ...   首先是删除掉 users 表 ...  下面再加上一个，删除掉 reviews 表里面的 user_id 这个字段  ..
          Schema::table('reviews', function(Blueprint $table)
          {
               $table->dropColumn('user_id');
          });
完在以后，去执行一下这个 migration  ...  打开命令行工具 ...  
php artisan migrate 
再打开数据库去看一下 ... 
在数据库里，你会发现多了一个 users 数据表 ...    这个表里有一些字段 ...  
再打开 reviews 表 ... 在这个表里，会多出一个 user_id 字段  ...  
Seed
下面，我们再去给 users 表添加一些演示数据  ...  可以去创建一个 seeder  ... 在 database 这个目录里面，找到 seeds
新建一个文件 ... 命名为 UserTableSeeder  ...    先去创建一个类 ...  叫做 UserTableSeeder ... 让它去继承 Seeder  ..  在这个类里面，定义一个 run 方法 ... 
先去准备一些数据  ..  这些数据就是要往 users 表里面插入的演示数据  .. 
注意这里，user_password 这个数据我们使用了 Hash 类的 make 方法，去加密了一下 ... 
最后再把这些数据插入到 users 这个表里面。 再去编辑一下 DatabaseSeeder.php  ... 添加一行代码 
$this->call('UserTableSeeder');
这样在运行 db:seed 命令的时候，就可以把在 UserTableSeeder 里面定义的数据插入到指定的数据表里面。
打开命令行工具 ..  输入 php artisan db:seed  ... 
再打开数据库 ...  找到 users 表 ...  现在，这里面，会有一些演示的数据 ...


02-01-登录与登出

想要让用户可以登录或登出，我们需要先去设计几个路由， 比如在请求 login 这个地址的时候，可以打开一个登录页面，这个页面上是一个可以登录的表单，上面可能会有让用户输入邮件，还有密码的表单元素。
点击登录以后，需要用设计好的处理登录请求的路由去处理，在这里，我们可以使用 Auth 类的 attempt 方法，去验证用户的登录请求。
检查用户是不是已经登录，用的是 Auth 类的 check 方法  ...  
登录成功以后，我们可以使用 Auth 类的 user 方法，再加上对应的属性的名称，可以得到用户的相关的信息，比如用户的名称，邮件等等。
另外，还需要去设计一个路由可以处理用户登出的请求，登出用户，可以使用 Auth 类的 logout 方法。


02-02-登录表单需要的路由与视图

下面，我们去创建一个控制器，在这个控制器里去创建一些方法，可以处理用户的登录登出这些请求。
控制器
打开 app  ... controllers  ... 新建一个文件 ... 命名为 AccountController.php   ..   Account 是帐户的意思 ... 你也可以随便怎么命名这个控制器。 打开这个文件 ... 新建一个控制器类 ..
<?php
class AccountController extends BaseController {}
然后在这个控制器里，我们可以先去定义一个处理请求用户登录页面的方法 ...    可以叫它 getLogin ...    在这个方法里，返回一个视图 ...   使用 View 类的 make 方法 ..  视图文件是 accout 目录下面的 login 这个视图 ... 
    public function getLogin() {
        return View::make('account.login');
    }
路由
先保存一下 ...  然后去添加一条处理请求用户登录页面的路由  ... 打开 routes.php  ... 使用 Route 类的 get 方法，因为这是一个 get 类型的请求 ..
请求的地址可以是 login  ... 你也可以根据自己的需求去定义这个地址 ...  请求发生的时候，使用 AccountController 这个控制器的 getLogin 这个方法去处理..这个方法就是刚才我们在 AccountController 里面定义的 ..
Route::get('login', 'AccountController@getLogin');
视图
这个方法需要用到一个视图  ...  下面，我们去创建这个视图  ... 打开 app ... views  ... 先新建一个目录 ... 命名为 account  ... 在这个目录里面，再去新创建一个文件 ... 叫做 login.blade.php  ... 这个视图文件是在 getLogin 这个方法里面要用到的。
打开这个视图文件  ...  它里面应该是一个登录用的表单  ...  先让它使用我们的 master 布局 ... 
@extends('movie.layout.master')   ... 
然后定义一个 content  区域 
@section('content')
@stop
在这个区域里面，应该就是这个登录表单的内容  ...   先用 Form::open 去开启一个表单  ... 表单结束的地方再用一个 Form::close 
然后是一个标题 ...  请登录  ...  另起一行 ..
再添加一个 email 类型的 input 元素 ...   元素的名字是 email  ... 
还需要一个 password 类型的 input 元素 ... 叫做 password ... 
最后再加上一个提交表单用的按钮 ...  按钮上面的文字是 登录 .. 
{{ Form::open() }}
     <h2>请登录</h2>
    {{ Form::email('email') }}
    {{ Form::password('password') }}
    {{ Form::submit('登录') }}
{{ Form::close() }}


02-03-请求登录

提交登录表单以后，会发现一个请求，默认这个请求用的是 post 方法，请求的地址就是 login 这个地址。下面，我们需要再去添加一个处理这个请求用的方法。
打开 AccountController  ...   再去添加一个方法 ...   可以叫它 postLogin  ...  用这个方法，可以处理用户登录的请求。
    public function postLogin() {}
首先我们可以获取到用户输入的邮件还有密码 ...    用的是 Input 类的 get 方法 ... 在这个方法里，可以指定要获取内容的表单元素的名字 ... 
        $email = Input::get('email');
        $password = Input::get('password');
然后用 Auth 类的 attempt 方法去登录用户 ...  这个方法需要一个数组参数  ... 数组里面的项目就是 users 表里面的字段的名称，还有对应值  .. 
Auth::attempt(array('email' => $email, 'password' => $password))
这行代码的意思就是，看看用户输入的邮件地址还有密码，是否匹配数据库里面的记录 ....  匹配的话，就让他登录  ... 
这里我们可以使用一个 if 语句  ...    如果登录成功的话 ... 可以把用户重定向到一个地址 ....    Redirect  ... 用它的 intended 方法 ... 这个方法会把用户带回到它试图登录之前的那个地址 ... 在这个方法里，也可以指定一个默认的重定向到的那个地址 ... 
        if (Auth::attempt(array('email' => $email, 'password' => $password)))
        {
            return Redirect::intended('/');
        }
在下面，再去设置一下，如果登录失败的话，把用户重定向到的地方 ...   这里我们再把用户带回到 login 这个地址 ... 
        return Redirect::to('login');
路由
保存 ...  再去添加一条路由  ... 打开 routes.php  ...  我们要添加一条 post 类型的路由  ... 使用 Route 类的 post 方法  ... 请求的地址是 login  ...  处理这个请求用的方法是 AccountController 控制器里面的 postLogin 这个方法 ... 
Route::post('login', 'AccountController@postLogin');
预览
下面，我们去试一下 ...  回到浏览器 . ..   打开登录页面 ... login 
先随便输入一个邮件地址 ...  这个地址在 users 表里是不存在的 ...  点击登录 ...    会把我重定向到 login 这个地址 ... 
再试一下 ... 输入我的邮件地址 ...  117663444@qq.com ... 还有密码 .. 
在创建用户模型的时候，我们已经往 users 表里面，添加了一条记录 ...  就是这个用户登录  .... 
点击 登录  ... 
会把我重定向到 首页 .. 而不是 login 页面 ... 说明我已经登录成功了 ...


02-04-表单样式

我们可以给这个表单添加一些样式 ...  这里我用的是 bootstrap 框架提供的样式 ...  在资料包里面，可以找到这个样式表  ...   把它放在 public  ...  css 这个目录下面 ... 
然后打开布局模板  ...  把这个样式表链接过来 ... 
再回到登录表单的视图文件 ... 我们需要给这些表单元素添加一些 css 类。这样才能用到刚才的样式表里面的样式 ... 
{{ Form::open(array('class' => 'form-signin')) }}
    <h2 class="form-signin-heading">请登录</h2>
    {{ Form::email('email', '', array('class' => 'form-control', 'placeholder' => 'Email')) }}
    {{ Form::password('password', array('class' => 'form-control', 'placeholder' => '密码')) }}
    {{ Form::submit('登录', array('class' => 'btn btn-lg btn-primary btn-block')) }}
{{ Form::close() }} 
保存 ... 
回到浏览器 ...  打开 login 这个地址 ...   在这个页面上，会出现一个用户登录用的表单  ...


02-05-验证用户是否登录

验证用户是否登录，用的是 Auth 类的 check 方法 ...  我们先去创建一个 blade 模板文件 ...  把它放在 layout 这个目录的下面 ..  名字是 toolbar.blade.php  ...   一个小工具栏 ... 在这个工具栏上面，可以显示用户是否登录了，如果登录的就显示用户的名字，还有一个登出按钮 ... 
如果没登录，就显示一个登录还有注册的按钮 ... 
这个工具栏上需要一些 html 代码，这个结构是 bootstrap 框架里面提供的 ...   
然后在这里，我们可以使用 blade 形式的 if 语句，去判断一下用户是不是登录了 ...   要检查的条件是 Auth::check()  ...  如果用户已经登录了，这个 check 方法会返回真的值  ... 
这样，就显示一个问候信息 ... 您好，然后是用户的名字 ....  访问用户帐户的信息，可以用 Auth 类的 user 方法，然后再加上对应的属性的名称  ...  这里我们需要的是 name 这个属性，也就是用户的名称 ... 
然后再显示一个登出的链接  ...    链接的的地址是 logout  ...  在后面我们再去定义处理请求 logout 的路由。
@else  ... 去设置一下，如果用户没登录的话要输出的东西 ... 
显示一个注册的链接 ...  地址是 signup  ...  这个页面我们在后面的视频去创建它 ... 
还有一个登录的链接   ... 链向的是 login 这个地址 ... 
最后再用一个 @endif ，结束这个 if 语句  ... 
  @if(Auth::check())
                <li><a href="#">您好，{{{ Auth::user()->name }}}</a></li>
                <li><a href="logout">登出</a></li>
                @else
                <li><a href="signup">注册</a></li>
                <li><a href="login">登录</a></li>
                @endif 
保存 ... 再打开 master 布局  ... 这个布局里，我们可以包含刚才创建的工具栏模板  ....   可以使用 @include  ...  指定一下要包含的模板文件 ...  layout 目录下面的 toolbar.blade.php 这个模板文件 ... 
@include('movie.layout.toolbar')
保存 ...   回到浏览器  ... 
因为在前面的视频里，我已经登录了 .. 所以，在这个工具栏上，会显示出登录以后的用户的名字 .. .


02-06-请求登出

在处理用户请求要登出的路由或者控制器的方法里面，用一个 Auth 类的 logout 方法，就可以让用户退出登录  ...  我们先去 AccountController 这个控制器时面，去创建处理这个请求的方法 .. 
可以叫它 getLogout  ... 
在这个方法里面，使用 Auth 类的 logout 方法 ...   然后再用 Redirect 方法，把用户重定向到一个地方 ...  Redirect  to ...  一个斜线  .. .表示应用的根目录  . . 这样用户登出以后，会回到应用的首页 ... 
    public function getLogout() {
        Auth::logout();
        return Redirect::to('/');
    }
再去设置一条路由  ...  打开 routes.php 
这个路由使用 get 方法 ... 请求的地址是 logout ...  处理的方法使用 AccountController 的 getLogout 方法 ... 
Route::get('logout', 'AccountController@getLogout');
保存 ...  再打开浏览器 .. 
现在我已经登录了 ..  所以会在工具栏上显示出我的名字 ..  这里我们点击 登出 ...
会把我重定向到首页 ... 
再打开登录的页面 ...  login  ...  你会看到，工具栏上现在会显示一个注册的链接，还有一个 登录的链接 ...  说明我现在是登出的状态 ... 
再重新登录一下 ... 输入邮件地址 ...  密码 ... 点击 登录  ... 
成功以后，工具栏上，又会显示出我的名字 .


02-07-记住我

用户登录以后，一段时间之后这个登录会过期，用户需要重新再次登录。我们可以记住用户的登录，让登录一直有效，直到用户自己要求退出登录 。这需要我们在 users 表里，添加一个 remember_token 的字段，在这个字段里会存储记住登录的 token 。
这样在尝试登录的时候，可以设置一下 Auth 类的 attempt 方法的第二个参数为 true .. 表示要记住用户的登录 ... 
打开登录表单的视图 ...  account .. login.blade.php ...  在这里我们可以添加一个复选框元素 ... 让用户自己决定是不是要记住登录 ... 
先给这个元素添加一个 label 元素 ...    用 Form 类的 label 方法 ...  标签是为 remember_me 这个元素准备的 ...  标签的文字是 记住我 ...  再给它上面添加一个 css 类 ... 
    {{ Form::label('remember_me', '记住我', array('class' => 'checkbox')) }}
再去添加复选框  ... 用 Form 类的 checkbox 方法 ...  复选框的名字是 remember_me  ...  
    {{ Form::checkbox('remember_me') }}
回到浏览器 ...   打开登录页面 ... 
在这个登录表单上，会显示一个 记住我 的复选框  ...  下面我们要再去编辑一下控制器 ...  当用户没有勾选这个复选框的话，把 attempt  方法的第二个参数设置为 false  ... 勾选的话就设置为 true  ...  表示用户愿意记住登录  .. 
控制器
打开 AccountController ...  找到 postLogin 这个方法 .. 
设置一个变量  ...  remember_me  ...  它的值根据用户是否勾选了记住我这个复选框来决定  ...   勾选了，它的值就是 true  ... 没勾选，它的值就是 false  ... 
$remember_me = Input::get('remember_me')? true : false;
然后再把这个 $remember_me 作为 attempt 方法的第二个参数 ..   这样的话，如果用户在登录的时候勾选了 记住我 ... 就会记住他的登录  ... 如果没勾选，登录会在一段时间以后过期  ... 
想要判断用户的登录是不是被记住了 ... 可以使用 Auth 类的 viaRemember 方法 ...  如果是，这个方法会返回 true  ...  如果你发现这个 viaRemember 不起作用，可以在 app/config 这个目录的下面，找到 session.php ...  然后把 driver 修改成 cookie  ... 
Auth::viaRemember()
预览 
下面我们再回到浏览器上去试一下 ...   打开登录页面 ...   再打开 Chrome 浏览器的开发者工具 ...  Resources  ...  Cookie  ...   在这里，会有一条 Cookie  ...  名字是 laravel_session  ... 
下面再去登录一下 ...   输入邮箱 ... 密码 ... 这次先不勾选 记住我 ... 点击 登录 ...
在  Cookie 这里，没有什么变化  ... 
下面，我们再重新登录一下 ..  先退出登录  ... 
然后再登录一次 ...  输入邮件 ... 密码 ... 这次我们勾选一下 记住我 ...  点击登录  ...
这次 Cookie 这里，会多了一条  ...  remember  ...  这就表示现在我已经用记住我的方式登录到了应用  ..


03-01-找回密码

用户把自己的密码整丢了以后，可以通过自己在注册的时候使用的邮件重新去设置自己的密码，这个功能 Laravel 框架已经给我们提供好了。不过需要我们自己去实施一下。
首先要确定用户模型已经实施了 RemindableInterface 这个接口 ...  Laravel 默认给我们提供的 User 模型已经实施了这个接口 ...  打开 app ... models  ...  打开 User.php
这里你可以看到  Use 已经  implements 了 RemindableInterface 这个接口 ...  并且使用了 RemindableTrait  ... 
创建数据表
下面，我们需要再去创建一个存储密码重置 token 的数据表 ...  创建这个数据表，可以使用 artisan 命令 .. 
打开命令行工具  ...  用 auth:reminders-table ，可以创建一个用来创建这个存储 token 数据表的 migration  ... 
php artisan auth:reminders-table
（#返回）在 app ...  database ...  migrations 里面。我们可以找到刚才用命令创建的 migration  ... 
就是这个 create_password_reminders_table  ... 
要创建的数据表的名字是 password_reminders  ... 表里有三个字段  ... email ，token ，还有 created_at ...
再回去执行一下这个 migration ...
php artisan migrate 
完成以后， 我们可以打开数据库看一下 ...  
在数据库里，会多了一个数据表 ... password_reminders  ...


03-02-找回密码的控制器

下面，我们再去准备一下处理找回密码的请求要用到的控制器。
使用 artisan 命令，可以去创建这个控制器。打开命令行工具 ...  php artisan ... 使用 auth 的 reminders-controller   ... 
php artisan auth:reminders-controller
完成以后，会给我们创建一个控制器  ...   
另外，我们还需要去在 routes.php 里面，添加一条路由 ... 
（#返回），打开 app ... controllers  ...   这里的 RemindersController.php 就是我们刚才使用命令创建的控制器 .
在这个控制器里有四个方法，分别可以处理重置密码的不同的请求。
getRemind  ... 这个方法会返回一个视图 ...   在这个视图里面，我们可以去准备一个重置密码的表单  ... 在这个表单上，一般就是一个带邮件字段的表单元素 .. 还有一个提交按钮 ..
点击提交以后，这个请求会交给 postRemind 这个方法来处理 ..  这个方法验证用户输入的邮件，确定数据库里面有这个邮件地址，就会生成一个 token ，存储在数据库里面，然后往这个邮件地址里面发一个重置密码的链接 ...   这个链接上会包含存储的 token  ...  
用户点击这个重置密码的链接 ...   这个请求会由下面的 getReset 方法来处理 ...   如果链接里面的 token 没有什么问题，这个方法，会返回一个视图  ... 
在这个视图上，应该就是用户用来重置密码的表单 ... 这个表单上要有一个隐藏的 token 字段  .. 这个字段的值会从这个方法里面发送到视图上 ...
还要有用户邮件，新的密码还有密码确认，最后还需要一个提交按钮... 
提交更新密码的请求，会用 postReset 这个方法来处理 ... 
这个方法要做的事，就是把用户重新设置的密码存储到数据库里面。
路由
下面，我们再去给这个控制器添加一个路由 ... 打开 routes.php  ...  用 Route 类的 controller 方法 ... 添加一个 REST 类型的控制器 ... 
Route::controller('password', 'RemindersController');
这样， 请求地址 password 斜线 remind ，就可以打开找回密码的表单 ... password 斜线  reset   ...  就是显示重置密码的表单  ...


03-03-找回密码的视图

这个视频，我们去创建找回密码的两个视图文件 ... 先去创建在 getRemind  方法里面需要的 remind 这个视图文件 ...  这个视图应该放在 password 这个目录下面 ...
打开 app  ... views ...  先去新建一个 password 目录 ... 
在这个目录里面，再去创建一个视图文件 ... 叫做  remind.blade.php   ..   可以先让它使用一个布局 ... 
再去定义一个 content 区域  ...
然后去设计一个找回密码用的表单  ... 这个表单很简单，只需要一个邮件字段 .. 还有一个提交按钮  ...   表单的开始使用 Form 类的 open 方法 ... 结束的地方用 Form 类的 close 方法 ...
然后在 form 标签上面添加一个 css 类 ... 可以给这个表单添加点额外的样式 ... 这个类样式我已经在样式表里面设计好了  ..
输入一个标题 ...   找回密码 ... 
然后用 Form 类的 email 方法去添加一个 email 字段  ...  再给这个元素添加点其它的属性 ...  先添加一个 class 属性 ...   它的值是 form-control ，然后再添加一个 placeholder 属性 ... 可以给这个元素添加一个提示的文字  ... 
另起一行 ... 再添加一个提交按钮 ... 使用 Form 类的 submit 方法 ... 按钮上的文字是 发送请求 ...   在这个按钮元素上再给它添加几个 css 类 ... 
@extends('movie.layout.master')
@section('content')
         {{ Form::open(array('class' => 'form-signin')) }}
    <h2 class="form-signin-heading">找回密码</h2>
    {{ Form::email('email', '', array('class' => 'form-control', 'placeholder' => 'Email')) }}
    {{ Form::submit('发送请求', array('class' => 'btn btn-lg btn-primary btn-block')) }}
    {{ Form::close() }}
@stop
完成以后 ... 保存 ... 
回到 浏览器 ..   打开 password 斜线  remind  ...   在这个页面上，我们会看到这个找回密码的表单  ...  
在 Email 里面，输入电子邮件的地址 ...  
然后点击 发送请求 ... 
这个表单会用 post 的方法，去请求 password/remind 这个地址 ..  这样 RemindersController 里面的 postRemind 会去处理这个请求 ..  如果用户输入的邮件没有问题的话，会向这个邮箱发送一个邮件 ... 
同时会存储一个 token 到数据库里面 ...  
不过这里我们遇到了一个问题，提示说 Cannot send message without a sender address  ...  意思是，我们没有为应用设置发件人的地址  ...   这是因为我们还没有配置好应用的邮件功能 ... 
在下面的视频里，我们再去看一下 ...


03-04-配置发送邮件的功能

Laravel 的邮件功能的相关配置是在 ...  app  ...  config  ...  mail.php 这个文件里面 ... 
在这里，我们可以先设置一下发送邮件的方法 ...  默认是通过  smtp 来发送  ...  
如果选择这种方式的话，我们需要再去设置一下，下面的 host  ... 也就是 smtp 的主机名  ...  设置成什么取决于你使用谁家的服务 ... 
默认是 mailgun ...  你可以换成其它的服务商提供的 smtp 的 host  ... 
另外还要设置一下 port  ...  也就是端口号 ...   这个值也取决于你使用的服务商  ...   587 的端口应该是使用加密的形式发送邮件 ... 
在下面的 from  选项 ...   可以设置一下发件人的邮件地址，还有名字  ...   这里我们可以先修改一下  ... 
address 就是发件人的邮件地址  ...  这里我设置成 service@ninghao.net  ...   再设置一下 name  ... 发件人的姓名  ...    这里设置成 ninghao  ... 
encryption ，是加密的协议 ..
username ，是在使用 smtp 的形式发送邮件的时候，要填写的一个用户名 ... 一般会由发送邮件的服务商来提供  ...   假设你使用 qq 的 smtp 发送邮件，这个用户名应该就是你的 qq 号  ... 
对于小型的网站，我们可以使用 qq ，163 或者 gmail 提供的 smtp 服务去发送邮件 ...    不过这些服务都会有限制  ...   对于大型的应用来说，建议使用专业的发送邮件的服务商  ... 或者创建自己的 smtp 服务器 ... 
下面的 password ，是跟用户对应的密码 ... 
sendmail 选项是，当我们使用 sendmail 发送邮件的时候  ...   在这里，你需要指定一下 sendmail 这个小程序所在的位置  ... 
最后，还有一个 pretend 选项 ... 它的值默认是 false  ...   如果设置成 true 的话 ...  应用会假装发送邮件 ...  并且会记录一个日志在日志文件里面 ... 
再回到这个配置文件的顶部 ... 
对于一般的小型应用来说，使用 sendmail 来发送邮件就可以了 ... 
这里因为我们是在本地做测试  ... 所以，可以把 driver 设置成 log  ...   这样发送的邮件会记录到应用的日志里面 ... 
保存一下 ... 
再回到找回密码的这个页面 ...   再输入一次邮件地址 ...  然后点击发送 ...   
因为我们使用了 log 作为发送邮件的引擎  ... 所以，这个邮件，可以在日志文件里找到 ... 
回到应用 ...   在  app  ...  storage  ...  logs 这个目录里面，打开 laravel.log  . .. 
在这个日志文件里面， 可以找到用来找回密码用的邮件  ...     如果你的这个文件里有很多内容  ...  浏览到这个文件的最底部，应该可以找到这封邮件  ... 
上面有邮件的发送的时间  ...    发送人  ..    发送到的地址 ...
还有邮件的具体的内容  ...    你会发现，这是一封 Password Reset 邮件 ...  重设密码的邮件  ... 
用户点击邮件里面的这个链接，会把他带到重设密码的页面上  ...


03-05-重置密码的视图

用户收到重置密码的邮件，点击了里面的链接，会打开一个重置密码的表单，下面，我们就去创建这个表单。
这个视图文件应该在 password 目录里面，叫做 reset.blade.php  ...  
新建文件.. 命名为 reset.blade.php ...  让它使用一个布局 ... 再定义一个 content 区域 .. 
再去设计这个重置密码的表单 ...  先开启这个表单  ... Form .. open 　....  结束这个表单，使用 Form ... close ..  表单里面应该有四个元素 ... 一个隐藏的 input 元素，它的值应该是从用户点击在邮件里面的链接上面获取到的，也就是重置密码用的那个 token ...  在提交这个表单的时候，Laravel 要用它跟数据库里面的 token 值进行比较 ... 
创建一个隐藏的表单元素，用的是 Form 类的 hidden 方法 ..  这个元素的名字是 token  .. 它的值，是从控制器的 getReset 方法里面传递过来的 ...  叫做 $token 
    {{ Form::hidden('token', $token)}}
再去添加一个邮件字段 ...  
    {{ Form::email('email', '', array('class' => 'form-control', 'placeholder' => 'Email')) }}
然后是一个密码字段  ...  可以让用户输入新的密码 ... 
    {{ Form::password('password', array('class' => 'form-control', 'placeholder' => '新密码'))}}
再添加一个密码确认的字段  ... 
     {{ Form::password('password_confirmation', array('class' => 'form-control', 'placeholder' => '密码确认'))}}
最后是一个提交按钮 ... 
    {{ Form::submit('确认', array('class' => 'btn btn-lg btn-primary btn-block')) }}
演示
下面，我们去演示一下 ...   在邮件里，找到 Laravel 给我发过来的重置密码用的链接  ...  复制一下 ...  回到浏览器  ... 粘贴过来 ...      请求这个地址  ...   会用 RemindersController 里面的 getReset 方法去处理 ...  它会先验证链接上的 token  ... 如果没有问题，就会打开 password/reset 这个地址 ... 
输入我的邮箱地址 ...  再输入新的密码 ...  再确认一下 ...   点击确认的话 ...
这个表单会用 post 方法去请求这个 password/reset  ...   RemindersController 里面的 postReset 会接收到这个请求 ... 没有问题话，把把新的密码保存到数据库里面 ...   同时也会把在 password_reminders 表里面的请求记录删除掉 .. 
我们可以到数据库里看一下  ... 
在 password_reminders 这个表里，会有一些要求重设密码的记录 ...   在浏览器里点击重设密码的链接以后，会对应这个表里面的 token 字段的值  ...   如果与这里的某条记录匹配  ... 就会打开重设密码的页面 ... 
再回到浏览器   ...  点击 确认 ...   这样会按照我们在这里输入的密码，重新设置用户的密码... 
再回到数据库  ...      你会看到，这里少了一条记录  ... 
现在，我就可以使用新的密码登录了 ...


04-01-用户注册

我们可以给用户准备一下注册帐户用的表单，输入规定的信息，提交以后，可以在数据库里存储用户的帐户信息，使用这个帐户信息用户就可以登录到我们应用上了。
先打开 AccountController ，在这个控制器里面，可以添加两个方法，一个方法用来显示一个注册帐户的表单  ..   
这个方法可以叫做 getSignup ..
    public function getSignup() {
    }
再去创建一个方法 ...  它可以处理提交这个表单的请求。这个方法可以叫做 postSignup 　...  
    public function postSignup() {
     }
处理请求注册表单的这个方法，可以返回一个视图 ...  在这个视图里面，就是注册帐户用的表单  ...   用一个 return ，再使用 View 这个类的 make 方法  ... 这个视图是在 account 目录下面 ... 叫做 signup.blade.php 
return View::make('account.signup');
下面，我们再去创建这个视图  ...    打开 app .  views ..  account ... 在这里，我们去创建这个 signup.blade.php  ...   
这个视图可以基于之前我们创建的重置密码用的表单去修改一下 ...  打开这个视图文件 ... 复制一下 ...  回到 signup.blade.php  ... 粘贴 过来 .. 
然后再修改一下 ...  改一下这个标题 ...  然后去掉这个 token 元素 ... 
这里再加上一个用户名的元素 ...
{{ Form::text('name', '', array('class' => 'form-control', 'placeholder' => '用户名')) }}
新密码这几个字 .. 可以换成 密码 ... 
postSignup
点击提交 .. 会用 post 方法去请求这个注册表单的地址 ...  下面，我们再去设置一下这个方法 ... 
在这个方法里，先去创建一个 User 模型 ，可以叫他 $user ...  $user = new User;   
设置一下它的 name 属性 ... 用户名 ...  它的值可以使用 Input 类的 get 方法去得到 ...  它的值是在 name 这个表单元素里面 ..
然后再设置一下 email 属性 ...  同样使用 Input 类的 get 方法 ... 它的值在 email 这个元素里面 ...
还有用户的密码属性 ...   用 Input 类的 get 方法，要获取到的是 password 里面的值 ...   要把密码存储到数据库里，我们得加密一下 ... 使用 Hash 类的 make 方法 ... 
最后，再使用模型的 save 方法，去把这些数据保存到数据库里面。
    public function postSignup() {
        $user = new User;
        $user->name = Input::get('username');
        $user->email = Input::get('email');
        $user->password = Hash::make(Input::get('password'));
        $user->save();
    }
路由
下面，再去设置两条路由 ... 打开 routes.php 
先用 Route 类的 get 方法，去设置一个用 get 方法的请求 ... 请求的地址是 signup ... 处理这个请求用的是 AccountController 控制器里面的 getSignup 方法 ... 
Route::get('signup', 'AccountController@getSignup');
再去添加一个 post 方法的路由 ...  请求的地址是 signup ...  处理它的方法是 AccountController 的 postSignup 这个方法 ... 
Route::post('signup', 'AccountController@postSignup');
保存 ... 回去浏览器里去看一下 ...
预览
打开 signup 这人地址 ... 
这里会给我们显示出一个用户注册的表单 ...   输入用户名 ...  xiaoxue ...  邮件地址 ...   53166188@qq.com ...   再输入密码 ...  111111 ，再确认一下密码 ... 
然后点击  确认 ... 
这样会用 post 方法去请求这个 signup 地址 ...   处理它的方法是 postSignup  ...  它会把用户在这里输入的东西，存储到数据库里面  ... 
打开数据库 ...  users 表 ... 
你会看到，这里多了一条记录 ... 就是 xiaoxue 这个用户的相关的信息 ... 
再回到浏览器 ..  我们可以去登录一下试试 ... 
打开 login ...  
输入邮箱地址 ...  53166188@qq.com  ...   密码 ...  点击登录 ... 
在工具条上，会显示 您好 ..  xiaoxue  ...  说明现在已经成功的使用了新注册的帐户登录到了我们的应用上面。


05-01-验证用户的输入 - validation

目前在我们创建的所有表单上，都还没有验证用户输入的内容的功能，比如这个注册表单 ...  如果我什么都不填 ，点击 确认  ... 一样可以正常的提交这个表单 ... 
打开数据库 ... 在这里，你会看到一条空白的记录 ...    没有用户名，没有邮件地址 ...  
Laravel 框架其实已经给我们提供了一套非常强大的验证用户输入的功能。你可以先制定一些规则， 比如哪些表单元素是必填的，里面的值必须是某种特定的类型，我们还可以规定值的长度，指定一个范围等等。
然后利用这些规则去对比用户输入的内容。如果都通过了，再去做指定的事情。如果用户输入的东西不符合我们定义的规则，可以获取到错误信息，然后把它们显示出来。


05-02-验证用户的输入 - 实践

这个视频我们去试一下使用 Laravel 的 Validator ，去验证用户输入的内容。
我们可以在处理提交注册的这个方法里面去试一下 ..  打开 AccountController 这个控制器 ...  找到 postSignup 方法 ...  在这个方法里，我们会直接把用户提交的内容放到数据库里面 ...  先把这些代码注释掉 ... 
然后，可以使用 Validator 类的 make 方法，去验证用户的输入 ...  这个方法有两个参数，类型都是数组 ... 第一个参数是要验证的表单元素的名字，还有用户提供的数据 ... 
第二个参数里面，是要验证的表单元素的名称 ... 还有跟它对应的规则 ...   
Validator::make()
比如我们要验证一下 username 这个表单元素 ...  array  ...   表单元素的名字是 username  ...  对应的值，就是用户在上面输入的内容  ... 可以使用 Input 类的 get 方法得到它 .. 
            array(
                'username' => Input::get('username')
            ),
再去定义一下这个 username 表单元素的规则 ...   设置一下 make 方法的第二个参数 ...  array  ...  名字是 username  ..  这个数组项目的值，就是应用到 username 这个表单元素上的规则 ...  我们先用一个 required  ...  这个规则的意思是元素是必填项目  ...   这样如果用户在提交注册的时候，没有输入内容，就不能通过这个验证 ... 
            array(
                'username' => 'required'
            )
Validator 的 make 方法会返回一个对象  ... 我们可以给它起个名字  ...   可以叫它 $validator  ... 
如果验证成功的话 ... 这个对象的 passes 方法就会返回 true .. 表示验证通过  ...   验证失败的话，这个方法会返回 false  ..   另外如果验证失败的话 ... 它的 fails 方法会返回 true  .. 
判断是否通过验证
下面，我们用一个简单的 if 语句去判断一下 ...   if .. $validator->passes()  ...  如果验证通过的话 ...     可以返回一行文字  ...   return  ... 成功创建用户 ...
else  ...  如果失败的话 ..  也返回一行文字  ...  return  ...  哪里出了点问题，再试一次吧 .. 
        if($validator->passes()) {
            return '成功创建用户!';
        } else {
            return '哪里出了点问题，再试一次吧。';
        }
下面，我们可以去试一下 . ... 
演示
先试一下直接提交这个表单  ...   这里会显示 哪里出了点问题，再试一次吧。
这是验证失败以后，我们要求返回的信息 .. . 因为现在我们已经给 username 这个表单元素添加了一个 必填 的规则  ...   所以没填写这个元素就会验证失败 ... 
回过来 ..  这次在用户名这里输入一个字符  ..  然后再点击 提交 .. 
这次会显示 成功创建用户 ... 因为用户输入东西通过了我们定制的规则 ...


05-03-处理错误信息

在验证失败的时候，我们可以使用 validator 的 messages 方法得到失败的具体的原因 ...   定义一个变量，存储得到的错误信息 .. 
    $messages = $validator->messages();
这样如果出错的话， $messages 里面，就会包含具体的错误。使用它的 all 方法，可以得到所有的错误信息。如果想得到个别表单元素的错误信息，可以使用 get 方法，再这个方法里，指定一下表单元素的名字 ... 这样会得到在这个表单元素上的错误 ... 
下面，我们用一个 foreach 语句，去循环的输出所有的错误  ...  foreach  ...  $messages  ... 用它的 all 方法 ..  as $message  ...    每次循环，要做的事就是去输出这个 $message  ... 在它后面再加上一个 <br> 标签 ... 这样每条错误信息都会显示在新的一行 ... 
            foreach ($messages->all() as $message) {
                echo $message . '<br>';
            } 
注释掉 return 这行代码 ... 然后保存 ... 回到浏览器上看一下 ... 
直接点击 确认  ... 
这次会给我们显示出具体发生的错误 ...  The username field is required.   意思就是 username 这个表单元素是一个必填项 .. 
withErrors
这个错误信息可以交给视图去处理，下面我们再去改进一下 ...    （#返回）
如果验证失败 ...  把用户重定向到 signup 这个页面 ... return ...  Redirect .. to ，重定向到 ..  signup ...  然后我们用一个 withErrors .. 
这个方法会把验证失败的信息传递到视图上 ..   因为是通过  session 传递的 .. 所以，这些错误信息只在下一次请求是可用的 ...  
这里，我们不需要再去先把错误信息用 messages 方法提取出来了 ..  可以直接把这个 validator 交给这个方法 ...
return Redirect::to('signup')->withErrors($validator);
然后注释掉其它的代码  ... 
下面，我们可以在视图上，把错误信息显示出来 ..  可以把它放在注册表单这个视图用的布局上 ... 
打开 master 这个布局 ...   在显示错误之前，先去判断一下，是不是有可以显示的错误  ... 
如果有 ... 就用 foreach ... 循环把错误都显示出来 ...   注意这里的 $errors 在所有的视图上都是可以使用的 ...  Laravel 会把错误信息放到它里面。
在每条错误信息的周围，可以添加一组段落标签  .. 上面加上几个类 ... 可以给错误信息添加点样式 ...  
        @if($errors)
            @foreach ($errors->all() as $error)
            <p class="alert alert-warning">{{ $error }}</p>
            @endforeach
        @endif
下面， 我们再去试一下 ... 
回到注册帐户的页面 ...  点击 确定  ... 
验证失败 ... 会把用户重定向到这个页面上 ...  并且在这里，会显示出错误信息 ... 
withInput
重定向到这个页面以后，用户在表单上填写的东西都会被刷新掉 ..  想要保留用户填写的内容 ... 可以使用一个 withInput 方法 ... 
(#返回)，打开 AccountController 控制器 ...  在这个 Redirect 的后面 .. 再加上一个 withInput() ...
return Redirect::to('signup')->withErrors($validator)->withInput();
保存 ...  再去试一下 ..
我们可以在邮件这里，输入点东西 ...  wanghao@ninghao.net
点击 确定  ...  因为没有填写用户名，所以会把我重定向回到 signup 这个页面 ...    同时，我之前在这个表单上填写的内容也会保留住  ...  这样我可以再去修改错误的地方 ..  然后重新提交 ...


05-04-更多验证的规则 - min 与 max

在每个表单元素上， 我们都可以添加多个验证的规则。比如这里，我们再给 username 这个表单元素添加一条规则  ...  这次我们要限制它的最小字符数 ... 
min
限制最小值的规则是 min ...  在这个 required 规则的后面，用一个 竖线，分隔一下不同的规则 ... 然后再输入 min 冒号 ... 在指定一下具体的最小值是多少  ... 
如果我们限制这个 username 的值是 numeric 数字的话 ...  这个 min 就表示最小的数值是多少 ..   而不是限制最小的字符数 .. 
保存  ... 回到浏览器 ...  先输入两个字符 ..  点击 确定  .. 
会提示 The username must be at least 5 characters.  用户名至少是5个字符 .. 
输入 wanghao  ...  再确定一下 ..  这次会通过验证 ... 
max
使用 max 规则，我们可以限制最大值 ...   （#返回）在这里，再加上一个 max 冒号 10 ..  这就表示 username 这个元素的值，最少要是 3 个字符，最多不能超过 10 个字符 ...  保存 ... 
输入 wanghao  ..  确定  ...   我在 username 里输入的字符串大于 5 个字符，少于 10 个字符  ... 所以可以通过验证 (#返回)
再试一下 ...  wanghaohahahahahahah  ... 确定 ... 
这次提示 The username may not be greater than 10 characters.  用户名不能超过 10 个字符...


05-05-验证邮件 - email 与 unique

下面，我们再去给 email 元素添加一个验证的规则 ..
(#返回) 先去设置一下要验证的东西 ... 
'email' => Input::get('email')
然后再去设置一下跟它对应的验证的规则 ..   先用一个 required ... 表示这是一个必填项 ..  再添加一个 email 规则 ...   这个规则可以验证用户是否使用了正确的邮件地址形式 ..  也就是至少要包含一个 @ 符号 ... 还有一个  点 什么东西 ... 
另外，我们还希望 email 字段的值必须是唯一的，也就是，如果用户输入的邮件地址，已经在我们的数据库里存在了 ... 就会显示一个错误 ... 
这个规则是 unique  ... 再指定一下要验证唯一性的数据表 ...  我们的用户信息放在 users 表里面，所以，要求 email 字段在这个表里必须是唯一的 ...  默认要验证的字段的名字就是 email ，如果在你的 users 表里面，存储 email 数据的字段不叫这个名字... 可以在这里特别去指定一下 ... 输入一个逗号 ... 然后再指定具体的字段名字 ...
'email' => 'required|email|unique:users',
再去浏览器上试一下 ... 
先输入一个用户名 ...  再输入一个不合规范的邮件地址 ...  wanghao@ninghao
确定  ... 提示 The email must be a valid email address. 必须使用有效的邮件地址 ....   因为刚才我输入的邮件地址没有点什么东西 ... 
再改一下，输入 wanghao@ninghao.net  ...   
确定 ... 这回没有验证的错误 ... 
我们给 email 表单元素还添加了一个是否在 users 表里唯一的验证规则 ...   再去试一下 ... 
这次在 email 元素里，输入一个在 users 表里面已经存在了的邮件地址 ..  117663444@qq.com 
再确定一下 ... 
这回提示  The email has already been taken.     email 已经被占用了。


05-06-验证密码 - between 与 confirmed

下面，我们去给密码也添加几个验证的规则 ... 
要验证的是 password 这个表单元素 ...  它的值，可以使用 Input 类的 get 方法得到 ... 
'password' => Input::get('password')
在下面，再去给它添加对应的规则 ... 
要添加规则的是 password  ...  先添加一个 required ...  表示这是一个必填的字段 ...  然后我们可以规定一下密码的字符数 .. .最少要是 6 个字符 ... 最多不能超过 12 个字符 ...   前面我们已经介绍过了，使用 min 还有 max 去设置最小还有最大值  ...  这里我们用一个 between  ...   去这去设置一下在两个值之间的规则 ...  先是最小值  .. 是 6 ...  然后是最大值 ... 是 12 ... 
最后再添加一个 confirmed  ...  这个规则是给这个元素添加一个确认的元素 ...   比如这里我们给 password 添加了这个 confirmed ...  这样需要在我们的表单里，有一个 password_confirmation 的表单元素， 并且要求用户，这两个字段的值必须一致才行 .. 
这个确认元素的命名方式就是，要求确认的元素的名字 ... 下划线 ...  接着是 confirmation ... 
'password' => 'required|between:6,12|confirmed'
确认
下面我们需要再去获取到 password_confirmation 这个元素的值 ... 
'password_confirmation' => Input::get('password_confirmation')
保存 ...  我们去浏览器上试一下这些规则 ... 
预览
输入用户名 ..  邮件地址 ...   再输入密码 ...  12345  ...  在确认一次 ... 12345
提示 The password must be between 6 and 12 characters. 密码要在 6 到 12 个字符之间 ... 
再试一下 ...  123456  ...  确认一次 ...  我回我们输入一个错误的密码 ...  1234567
提示 ... The password confirmation does not match.  密码确认不匹配 ... 
123456 ...  123456  ... 再确认一次 ... 
提示成功创建用户。


05-07-完善验证规则

这个视频我们完善一下验证用户输入的功能。目前我们把所有的验证规则都放到了控制器的方法里面。如果其它的地方需要用到这些规则，我们需要在其它的方法里面重新去定义这些规则。
其实我们可以在模型里，去定义这个验证的规则 ...  
先复制一下定义这个规则的数组 ...   然后打开 Use 模型 ...    
在这个模型里，我们可以定义一个静态的属性 ..  命名为 rules ...  它的值就是规则数组 ... 
    public static $rules = array(
        'username' => 'required|min:3|max:10',
        'email' => 'required|email|unique:users',
        'password' => 'required|between:6,12|confirmed'
    );
再回到 AccountController 这个控制器 ...  在 Validator 的 make 方法里，现在用的是 Input 类的 get 方法，分别得到用户输入的内容 ...  这里我们使用 Input 类的 all 方法，可以一次得到用户输入的所有的东西 ..  
然后它的第二个参数是验证规则数组 ... 在 User 模型里已经定义好了这个数组 ...  因为它是一个静态属性 .. 所以，直接使用 User 冒号冒号 $rules  ..  可以得到这个验证规则 ... 
$validator = Validator::make(Input::all(), User::$rules);
这样我们的控制器就会瘦一点了 ...   
再去浏览器上看一下 ...  什么也不填，直接点击 确认 ...  会出现错误的提示信息 ... 
再回到控制器 ...


05-08-Flash Data

如果通过验证的话 ...  先去存储一下用户的帐户信息 ...   
然后把用户重定向到 登录 页面 ...  使用 Redirect 类的 to 方法 .. .   重定向到 login 这个页面 ...    可以捎带着一条信息 ...   这个信息是通过 session 存储的 ..  可以在下一次请求的时候用一回  ...  所以这也叫 flash data  ...  一闪就没了 ..  
可以使用一个 with 方法 ...  信息的名字是 message  ...  一会儿用这个名字可以得到这个信息的具体内容 ... 第二个参数就是这个信息的具体的内容 ... 
            $user = new User;
            $user->username = Input::get('username');
            $user->email = Input::get('email');
            $user->password = Hash::make(Input::get('password'));
            $user->save();
            return Redirect::to('/login')->with('message', '成功注册了会员，现在可以登录了！');
在视图里面，使用 Session 类的 get 方法，可以得到这个 message 信息 .. .  打开 master 这个视图 .. 
先用 if 去判断一下，是不是有可以显示的 message  ...   这里我们用 Session 类的 has 方法作为要判断的条件  ... 
如果有 ...  去把它显示出来 ...  放在一组 p 标签里面 ... 上面添加两个类 ... alert ... 还有 alert-info ..
信息的具体内容，使用 Session 类的 get 方法得到它 ... 
        @if(Session::has('message'))
            <p class="alert alert-info">{{ Session::get('message') }}</p>
        @endif
预览
下面，我们去试一下 ... 
打开注册的页面 ...  输入用户名 ...  zhangsan  ...   邮件地址 ...  zhangsan@ninghao.net  ... 再输入密码 ...  然后再确认一次 ... 
点击 确认 ... 
如果没有问题的话 ... 会把用户带到 login 这个页面 ...   在这个页面上，会显示一个 flash 信息。提示用户成功注册了会员，现在可以登录了。
输入邮件的地址 ...  zhangsan@ninghao.net  ...  再输入它的密码 ...  点击登录  ... 
在工具栏上，会显示出当前登录的用户的名字 ...


05-09-自定义错误信息

之前在验证发生错误以后，在页面上显示的信息都是英文的 ...  这些信息我们是可以自己定义的。可以把它放在模型里面 ...  打开 User 这个模型 ...
先去添加一个静态的属性 ...   可以叫做 $messages，它可以是一个数组，在这个数组里面，我们可以自定义验证错误的提示信息。数组里面的每个项目，可以先用一个验证规则的名字 ...  然后再去设置跟它对应的值  ... 比如，去给 required 这个规则自定义一条信息 ...  输入 required ...  然后是对应的值  ...  在这里面，可以使用 冒号 attribute 作为元素的占位符，也就是说，这个 冒号 attribute 会变成使用这个 required 规则的表单元素的名字 ...  
     public static $messages = array(
         'required' => ':attribute 字段是必填项'
     );
先保存一下 ...  然后得把这个 $messages 作为 Validator 类的 make 方法的第三个参数传递进去 ... 打开 AccountController 控制器。
把在 User 模型里面的 $messages 这个静态属性，交给 Validator 的第三个参数  ... 
$validator = Validator::make(Input::all(), User::$rules, User::$messages);
保存 ... 再去浏览器上看一下 ... 
直接点击 确认 ...   这回显示的验证错误的提示信息就是我们自己定义的了 ...  表单元素的名称  ...  也就是在自定义信息里面，用 :attribute 表示的 ...  后面再加上自定义的中文提示内容 ... 
不过用户可能并不知道  username,email, password  分别表示的都是哪个表单元素 ...   
这样在自定义这个信息的时候，我们可以更具体一些 ... 可以专门给指定的表单元素还有对应的验证规则去添加自定义的提示信息 .. 
再回去改一下 ...    打开 User 这个模型 .. 
先复制一条这个自定义的信息  ...  这里，我们在规则名的前面，加上一个具体的表单元素的名字 .. 比如给 username 的 required 规则添加一条自定义的信息 ..  在这个规则名的前面，加上 username 然后一个点 ... 接着就是这个规则的名称 .. 
修改一下信息的内容  .. 因为这个条信息是专门为用户名这个元素准备的，所以，在这里，可以直接输入用户名字段是必须项 .. 在字段名称的周围可以加上一组加粗显示的标签 ... 
     public static $messages = array(
         'required' => ':attribute 字段是必填项',
         'username.required' => '<strong>用户名</strong> 字段是必填项'
     );
保存 ... 再回去看一下 ..   点击 确认 ... 
这次显示的提示信息里面，用户名这个元素的 required 规则的验证信息会显示更具体的信息。
使用这种方法，我们可以分别对每个元素的每条规则都去添加这样的自定义提示信息。


06-01-身份验证过滤器 - auth

有些地址，我们希望只有注册用户，并且登录以后才能访问，或者拥有特定权限的用户才能访问。
对于想要使用身份验证来保护的这些地址，可以对它们使用 auth 过滤器。
比如，现在我们要打开 movies/create 这个地址 ...   现在，不需要登录也能打开 ... 下面，我们对这个地址应用一个 auth 过滤器 ... 这样，用户在尝试打开它的时候，需要先登录才行。
处理这个请求的是在《Laravel 基础教程》这个课程里面创建的 MovieController 这个控制器。
这里的 create ，就是处理访问 movies/create 请求的方法 ... 
对这个请求添加 auth 过滤器，可以直接在  routes.php 里面，设置一条具体的路由，然后去应用这个过滤器 ...   另外，我们也可以直接在控制器里面去添加过滤器 .. 先看一下第一种方法 ... 
打开 routes.php ...
添加一条路由 ... 使用 Route 类的 get 方法 ... 添加一个 get 请求的路由 ...  请求的地址是 movies/create  ...  然后可以把一个数组作为这个方法的第二个参数  ... 
这个数组里面，第一个项目就是要使用的过滤器的类型，还有具体的过滤器的名字 .. .  过滤器有 before 还有 after 类型 ... before 类型的过滤器会在请求访问之前使用 ... after 类型的过滤器会在请求访问之后使用 ...
因为我们想在请求之前就要求用户登录  ... 所以，这里用一个 before 类型的过滤器 ...   它的值 ... 就是要使用的过滤器的名字 ...  这里我们要用的是 auth 这个过滤器 .. 
然后再设置一下数组里面的第二个项目 ... 就是使用哪个控制器里面的哪个方法去处理 movies/create 这个请求 ...  先用一个 uses ...  它的值是控制器还有控制器的方法的名字  ... 
Route::get('movies/create', array(
    'before'    => 'auth',
    'uses'      => 'MovieController@create'
));
这样，当有人请求访问 movies/create 的时候，会对这个请求应用  auth 过滤器，也就是要求没有登录的用户先登录一下 ...  这个请求由 MovieController 这个控制器的 create 方法去处理... 
filter
在演示之前，我们先去看一下过滤器 ... 应用里的过滤器，都会在 app 目录下面的  ... filters.php 这个文件里面 ... 
在这里，可以看到 auth 这个过滤器  ..  它的作用就是，使用 Auth 类的 guest 方法，判断一下用户有没有登录  ...  如果没登录就把用户重定向到登录页面 ... 
在用户登录成功以后，我们可以把用户带回到它之前想要访问的页面 ... 不过需要再去设置一下处理登录请求的方法 ... 
intended
打开 AccountController 这个控制器 ..  我们设计的处理登录请求的方法在这个控制器里面 ...  就是这个 postLogin 方法 ... 
在这里，登录成功以后，使用 Redirect to，把用户重定向到应用的首页 ... 这里，我们把 to 这个方法换成 intended ... 这样会把用户重定向到它之前想要访问的页面 ...  在这个方法里，也可以设置一下默认的重定向到的地址 ...  
演示
保存 ...  再到浏览器上试一下 ... 
打开 movies/create 这个页面 ... 因为我还没有登录  .. 所以，会把我重定向到登录的页面上 ... 
输入邮件地址 ... 密码 ...  然后点击登录  ... 
成功以后，会把我带回到我要访问的创建电影的这个页面 ...


06-02-简单的权限管理

在创建 users 数据表的时候，我们添加了一个 is_admin 的字段 ...  用来标记用户是不是管理员 ...  这个视频我们可以利用这个字段去做点事情 ... 当用户要访问创建电影页面的时候，不但要求用户先登录 ... 登录以后，还要查看一下用户是不是管理员，也就是用户记录的 is_admin 这个字段里面的值是不是 1 ，如果是的话，就显示创建电影的页面，如果不是的话，可以把用户重定向到一个地方，带一条提醒信息，说明一下原因。
先打开 MovieController 这个控制器 ...  打开 create 方法 ... 
在这里，先用一个 if 语句，判断一下当前登录的用户是不是管理员 ...  访问当前登录用户的信息，用的是 Auth 类的 user 方法 ...  后面加上属性的名字 ...  is_admin ...  如果是，就把请求指向一个视图，也就是显示出创建电影的表单 ... 
如果不是的话 ...  可以把用户重定向到一个指定的地方 ...   再加上一条提醒的信息 ... 
     public function create()
     {
          if(Auth::user()->is_admin){
              return View::make('movie.form');
          }
          return Redirect::to('signup')->with('message', '哎呀，没有权限访问 : (');
     }
回到浏览器 ...  打开创建电影的页面 ... 
现在我用的是 wanghao 这个用户登录的 ...  他是管理员 ... 所以会显示这个创建电影页面 ..     下面，我们先退出一下 .. 
然后再打开 movies/create 　...   提示登录  ... 这次我用 xiaoxue 这个用户登录一下 ..  她不是管理员 ...    xiaoxue@ninghao.net  ...  密码 ... 111111
登录成功以后，会尝试把 xiaoxue 重定向到她之前访问的 movies/create 页面 .. 但是因为 xiaoxue 不是管理员 ...  所以，又会反她重定向到这个 signup 页面 ...  
页面上，会显示提示用户没有权限访问创建电影的页面 ... 
这个视频我们演示了一个简单的权限的应用  ...  对于更复杂的应用，我们可以使用第三方提供的包来扩展 Laravel 的功能，比如可以使用 Sentry 。


06-03-CSRF

Cross-site request forgery 就是 CSRF ...  跨站请求身份伪造。这是一种功击的方法 ...  就是如果你的网站的用户访问了黑客提供的页面，在这个页面上，黑客可以很容易让用户向你的网站去提交请求，如果你的用户已经登录了你的网站，你的网站一般很难判断这是一次功击，并不是用户自己发出的请求。这就是 CSRF。
防止 CSRF 比较有效的办法就是，去生成一个 token ，放在用户的 session 里面，在要提交的表单上，会有一个隐藏的 token 字段，当用户提交表单的时候，会去比较这两个 token  ，如果匹配就正常去执行这个请求，如果不匹配就会放弃。
如果使用 Laravel 的 Form 类的 open 方法去开始一个表单，在表单里面，已经包含了这个隐藏的 token 字段 ..   但是默认情况下，提交表单的时候，不会去对比表单里的 token 还有用户 session 里的 token  .. 
想要去对比的话，我们需要在路由或者控制器上，去使用 csrf 这个过滤器 ... 
先打开 routes.php ，之前已经介绍了怎么样在路由上去应用过滤器 ...  想在这个路由上使用多个过滤器 ... 可以用 竖线分隔一下 ...   再输入一个 csrf  ... 
Route::get('movies/create', array(
    'before'    => 'auth|csrf',
    'uses'      => 'MovieController@create'
));
不过在这个路由上，不能使用 csrf 这个过滤器，因为没有对比的 token 。先去掉它 ... 
下面，我们再去看看怎么样在控制器里面使用过滤器 ...  打开 MovieController 这个控制器 ... 
在控制器里使用过滤器，可以把过滤器放在构造函数里面 ...  先去创建一个构造函数  .. .  public function ...  __construct  ...  然后使用当前对象的 beforeFilter .. 表示要去添加 before 类型的过滤器 .. 就是在请求之前的过滤器 ... 
第一个参数是过滤器的名字 ... 这里我们用一个 csrf  ...  
第二个参数是这个过滤器应用的范围  ... 它是一个数组  ..  然后输入一个 on ... 表示，把这个过滤器应用到什么地方 ...   它的值设置成 post 竖线 ...  put ...  delete  ...  
它的意思就是，把 csrf 这个过滤器，用在使用 post ，put 或者 delete 请求的方法上 ...   基本就是除了 get 方法以外的所有的方法 .. .
     public function __construct() {
         $this->beforeFilter('csrf', array('on' => 'post|put|delete'));
     }
保存 ...   
演示
打开电影列表页面 ...   我们可以查看一下这个 删除 按钮元素 ...  注意在这个表单上，有一个隐藏的 token 元素 ...  在点击 删除 的时候 ..  应用在 MovieController 控制器上应用了 csrf 过滤器 ..  所以，提交这个删除请求，就会去比较这里的 token 跟用户 session 里面的 token  ... 
我们可以修改一下这个 token 的值  ...   然后再点击这个删除按钮 ... 
会显示一个错误  ...  TokenMismatchException ...   token 不匹配的错误  ... 
再点击一个没有修改 token 值的删除按钮 ...   
token 匹配 ...  就会成功的删除掉这个电影内容  ...


